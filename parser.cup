import java_cup.runtime.*;

/*
* Ops
*/
terminal TIMES;
terminal PLUS;
terminal MINUS;
terminal DIVIDE;
terminal SEMI;
terminal COLON;
terminal COMMA;
terminal UMINUS;
terminal UPLUS;
terminal LEFT_PAREN;
terminal RT_PAREN;
terminal LEFT_BRKT;
terminal RT_BRKT;
terminal LEFT_CURL;
terminal RT_CURL;
terminal EQ;
terminal EQEQ;
terminal GTR;
terminal LESS;
terminal LESS_EQ;
terminal GTR_EQ;
terminal NOT_EQ;
terminal OR;
terminal AND;
terminal QUES;
terminal BNOT;

/*
* Other
*/
terminal IF;
terminal FI;
terminal ELSE;
terminal FINAL;
terminal VOID;
terminal CLASS;
terminal PRINT;
terminal RETURN;
terminal PRINTLINE;
terminal READ;

/*
* Types
*/
terminal INT;
terminal FLOAT;
terminal CHAR;
terminal BOOL;
terminal STRING;

/**
* Literals
* terminal INTLIT;
* terminal STRINGLIT;
* terminal CHARLIT;
* terminal FLOATLIT;
* terminal IDENT;
*/
terminal TRUE;
terminal FALSE;

/**
* Terminals that require use to build an AST for
*/
terminal String INTLIT;
terminal String FLOATLIT;
terminal String CHARLIT;
terminal String STRINGLIT;
terminal String IDENT;

/**
 * The following two lines define a dummy non-terminal and grammar rule.  CUP
 * needs at least one rule to run without errors.
 */


non terminal ProgramAST             prog;
non terminal MemberdeclsAST         memlist;
non terminal FielddeclsAST          fieldlist;
non terminal FieldAST               field;

non terminal MethoddeclsAST         methods;
non terminal MethodAST              meth;

non terminal OptionalfinalAST       fin;

non terminal TypeAST                type;

non terminal ReturntypeAST          returntype;

non terminal OptionalexprAST        optexpr;
non terminal OptionalsemiAST        optsemi;

non terminal ExprAST                expr;
non terminal CastexprAST            castexpr;
non terminal FunctionexprAST        funcexpr;
non terminal SingleexprAST          singleexpr;
non terminal UnaryexprAST           unaryexpr;
non terminal BinaryexprAST          binaryexpr;
non terminal TernaryexprAST         ternaryexpr;


non terminal BinaryOp               binop;
non terminal IntlitAST              int;
non terminal CharlitAST             char;
non terminal FloatlitAST            float;
non terminal StringlitAST           string;
non terminal IdentAST               ident;

non terminal NameAST                name;

precedence left OR;
precedence left AND;
precedence left EQEQ, NOT_EQ;
precedence left GTR, GTR_EQ, LESS, LESS_EQ;
precedence left MINUS, PLUS;
precedence left TIMES, DIVIDE;

start with prog;

prog                    ::= CLASS ident:i LEFT_CURL memlist:m RT_CURL
                            {: RESULT = new ProgramAST(i, m); :}
                        ;

memlist                 ::= fieldlist:i methods:m
                            {: RESULT = new MemberdeclsAST(i, m); :}
                        ;

fieldlist               ::= field:f fieldlist:fs
                            {: RESULT = new FielddeclsAST(f, fs); :}
                        |   {: RESULT = new FielddeclsAST(); :}
                        ;

field                   ::= FINAL type:t ident:i optexpr:e SEMI
                            {: RESULT = new FieldAST(new OptionalfinalAST(true), t, i, e); :}
                        |   type:t ident:i optexpr:e SEMI
                            {: RESULT = new FieldAST(new OptionalfinalAST(false), t, i, e); :}
                        |   type:t ident:id LEFT_BRKT int:i RT_BRKT SEMI
                            {: RESULT = new FieldAST(t, id, i); :}
                        ;

methods                 ::= meth:m methods:ml
                            {: RESULT = new MethoddeclsAST(m, ml); :}
                        |   {: RESULT = new MethoddeclsAST(); :}
                        ;

meth                    ::= returntype:t ident:i LEFT_PAREN  ident:a RT_PAREN LEFT_CURL  RT_CURL optsemi:semi
                            {: RESULT = new MethodAST(t, i, semi); :}
                        ;

returntype              ::= type:t
                            {: RESULT = new ReturntypeAST(t); :}
                        |   VOID
                            {: RESULT = new ReturntypeAST(true); :}
                        ;

optexpr                 ::= EQ expr:e
                            {: RESULT = new OptionalexprAST(e); :}
                        |   {: RESULT = new OptionalexprAST(); :}
                        ;

optsemi                 ::= SEMI
                            {: RESULT = new OptionalsemiAST(true); :}
                        |   {: RESULT = new OptionalsemiAST(false); :}
                        ;

type                    ::= INT
                            {: RESULT = new TypeAST("int"); :}
                        | FLOAT
                            {: RESULT = new TypeAST("float"); :}
                        | STRING
                            {: RESULT = new TypeAST("string"); :}
                        | CHAR
                            {: RESULT = new TypeAST("char"); :}
                        ;

name                    ::= ident:i
                            {: RESULT = new NameAST(i); :}
                        |   ident:i LEFT_BRKT expr:e RT_BRKT
                            {: RESULT = new NameAST(i, e); :}
                        ;

expr                    ::= funcexpr:f
                            {: RESULT = new ExprAST(f); :}
                        | castexpr:f
                            {: RESULT = new ExprAST(f); :}
                        | singleexpr:f
                            {: RESULT = new ExprAST(f); :}
                        | unaryexpr:f
                            {: RESULT = new ExprAST(f); :}
                        | binaryexpr:f
                            {: RESULT = new ExprAST(f); :}
                        | ternaryexpr:f
                            {: RESULT = new ExprAST(f); :}
                        ;

castexpr                ::= LEFT_PAREN type:t RT_PAREN expr:e
                            {: RESULT = new CastexprAST(t, e); :}
                        ;

/*
* THIS NEEDS ident:a swapped with args
*/

funcexpr                ::= ident:i LEFT_PAREN RT_PAREN
                            {: RESULT = new FunctionexprAST(i); :}
                        |   ident:i LEFT_PAREN ident:a RT_PAREN
                            {: RESULT = new FunctionexprAST(i, a); :}
                        ;

/*
* Not sure if (expr) works well here
*/

singleexpr              ::= name:n
                            {: RESULT = new SingleexprAST(n); :}
                        | int:n
                            {: RESULT = new SingleexprAST(n); :}
                        | float:n
                            {: RESULT = new SingleexprAST(n); :}
                        | string:n
                            {: RESULT = new SingleexprAST(n); :}
                        | char:n
                            {: RESULT = new SingleexprAST(n); :}
                        | TRUE
                            {: RESULT = new SingleexprAST(new BooleanAST(true)); :}
                        | FALSE
                            {: RESULT = new SingleexprAST(new BooleanAST(false)); :}
                        | LEFT_PAREN expr:e RT_PAREN
                            {: RESULT = new SingleexprAST(e); :}
                        ;


unaryexpr               ::= BNOT expr:e
                            {: RESULT = new UnaryexprAST("~", e); :}
                        | MINUS expr:e
                            {: RESULT = new UnaryexprAST("-", e); :}
                        | PLUS expr:e
                            {: RESULT = new UnaryexprAST("+", e); :}
                        ;

binaryexpr              ::= expr:e1 binop:b expr:e2
                            {: RESULT = new BinaryexprAST(e1, b, e2); :}
                        ;

ternaryexpr             ::= LEFT_PAREN expr:e1 QUES expr:e2 COLON expr:e3
                            {: RESULT = new TernaryexprAST(e1, e2, e3); :}
                        ;

binop                   ::= TIMES
                            {: RESULT = new BinaryOp("*"); :}
                        | DIVIDE
                            {: RESULT = new BinaryOp("*"); :}
                        | PLUS
                            {: RESULT = new BinaryOp("*"); :}
                        | MINUS
                            {: RESULT = new BinaryOp("*"); :}
                        | LESS
                            {: RESULT = new BinaryOp("*"); :}
                        | GTR
                            {: RESULT = new BinaryOp("*"); :}
                        | LESS_EQ
                            {: RESULT = new BinaryOp("*"); :}
                        | GTR_EQ
                            {: RESULT = new BinaryOp("*"); :}
                        | EQEQ
                            {: RESULT = new BinaryOp("*"); :}
                        | NOT_EQ
                            {: RESULT = new BinaryOp("*"); :}
                        | OR
                            {: RESULT = new BinaryOp("*"); :}
                        | AND
                            {: RESULT = new BinaryOp("*"); :}
                        ;


int                     ::= INTLIT:i
                            {: RESULT = new IntlitAST(i); :}
                        ;

float                   ::= FLOATLIT:i
                            {: RESULT = new FloatlitAST(i); :}
                        ;

char                    ::= CHARLIT:i
                            {: RESULT = new CharlitAST(i); :}
                        ;

string                  ::= STRINGLIT:i
                            {: RESULT = new StringlitAST(i); :}
                        ;

ident                   ::= IDENT:i
                            {: RESULT = new IdentAST(i); :}
                        ;
